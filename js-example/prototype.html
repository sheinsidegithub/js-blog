<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script type="text/javascript">
		//构造函数的继承
		//在子类的构造函数中，调用父类的构造函数
		function Sub(value){
			Super.call(this);
			this.prop = value;
		}
		//是让子类的原型指向父类的原型，这样子类就可以继承父类原型。
		Sub.prototype=Object.create(Super.prototype);
		Sub.prototype.constructor=Sub;
		Sub.prototype.method="";

		//这种写法也有继承的效果，但是子类会具有父类实例的方法
		Sub.prototype = new Super();
		

		function Shape(){
			this.x = x;
			this.y = y;
		}
		Shape.prototype.move = function (){
			this.x += x;
			this.y += y;
			console.log('Shape moved');
		}
		function Rectangle (){
			Shape.call(this);
		}
		Rectangle.prototype = Object.create(Shape.prototype);
		Rectangle.prototype.constructor=Rectangle;
		var rect = new Rectangle();
		rect.move(1,1);

		var module1={
			_count : 0,
			m1 : function(){

			},
			m2 : function(){

			}
		}
		//这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。
		module1._count = 5;
		//我们可以利用构造函数，封装私有变量。
		function StringBuilder(){
			var buffer = [];
			this.add = function(str){
				buffer.push(str);
			};
			this.toString = function(){
				return buffer.join('');
			};
		}
		//上面这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。

		function StringBuilder(){
			this._buffer=[];
		}
		StringBuilder.prototype={
			constructor:StringBuilder,
			add:function(str){
				this._buffer.push(str);
			}
			toString : function(){
				return this._buffer.join('');
			}
		}
		//以上这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。
		//封装私有变量：立即执行函数的写法
		var module1 = (function(){
			var _count = 0;
			var m1 = function(){
				//..
			}
			var m2 = function(){
				//...
			}
			return {
				m1 : m1,
				m2 : m2
			}
		})()
		//使用上面的写法，外部代码无法读取内部的_count变量。这就是js模块的基本写法。

		//如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。
		var module1 = (function(mod){
			mod.m3 = function () {
				//...
			};
			return mod;
		})(module1);
		//上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。
		//在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。
		var module1 = (function(mod){
			mod.m3 = function(){
				//...
			}
			return mod;
		})(window.module1 || {});
		function a(){
			var b=1;
			var c=function(){
				console.log(b);
			}
			return c;
		}
		var foo = a();
		console.log(foo())

	</script>
</body>
</html>